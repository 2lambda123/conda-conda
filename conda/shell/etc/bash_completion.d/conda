# Copyright (C) 2012 Anaconda, Inc
# SPDX-License-Identifier: BSD-3-Clause

# bash_completion for conda.
#
# This was initially based on completion support for `fish`, but later extended
# complete options for subcommands and files/dirs/paths as appropriate.
#
# Dynamic option lookup uses a cache that persists for the duration of the shell. If you
# Updates to the conda command options are relatively rare, but there is a small chance
# that this cache will hold incorrect/incomplete values. A restart of your shell will
# fix this.

# If this completion file is 'installed' under
#
#   /etc/bash_completion.d/,
#   /usr/share/bash-completion/completions/, or
#   ~/.local/share/bash-completion/completions/,
#
# rather than being managed via the `conda shell.bash hook`, then this file may
# be sourced before conda is setup.  To support this we allow for a potential
# late initiallization of the _CONDA_ROOT environment variable

## TODO

function __comp_conda_ensure_root() {
    if [[ -z ${_CONDA_ROOT} ]] && type -t conda >/dev/null; then
        \export _CONDA_ROOT=$(conda config --show root_prefix | cut -d" " -f2)
    fi
}

function __comp_conda_commands () {
    for f in $_CONDA_ROOT/lib/python*/site-packages/conda/cli/main_*.py
    do
        \expr match "$f" '.*_\([a-z]\+\)\.py$'
    done

    for f in $_CONDA_ROOT/bin/conda-*
    do
        if test -x "$f" -a ! -d "$f"
        then
            \expr match "$f" '^.*/conda-\(.*\)'
        fi
    done
    echo activate
    echo deactivate
}

function __comp_conda_env_commands() {
    for f in $_CONDA_ROOT/lib/python*/site-packages/conda_env/cli/main_*.py
    do
        \expr match "$f" '.*_\([a-z]\+\)\.py$'
    done
}

function __comp_conda_envs() {
    echo base
    conda config --json --show envs_dirs | \
        python -c "import json, os, sys; from os.path import isdir, join; print('\n'.join(d for ed in json.load(sys.stdin)['envs_dirs'] if isdir(ed) for d in os.listdir(ed) if isdir(join(ed, d))))"
}

function __comp_conda_packages() {
    conda list | awk 'NR > 3 {print $1}'
}

# cache conda subcommand help lookups for the duration of the shell
declare -A __comp_conda_cache=()
__comp_conda_ensure_root

_comp_conda()
{
    \local cur prev words cword
    _init_completion || return

    __comp_conda_ensure_root

    \local word_list
    if [[ $cur == -* ]]; then
        case "$prev" in
            conda)
                word_list=$(_parse_help conda '-h')
                ;;
            *)
                if [[ -z ${__comp_conda_cache[$prev]} ]]; then
                    word_list=$(conda $prev -h 2>&1 | _parse_help -)
                    __comp_conda_cache[$prev]=$word_list
                else
                    word_list=${__comp_conda_cache[$prev]}
                fi
                ;;
        esac
    else
        case "$prev" in
            conda)
                word_list=$(__comp_conda_commands)
                ;;
            env)
                word_list=$(__comp_conda_env_commands)
                ;;
            activate)
                if [[ $cur == ./* || $cur == /* ]]; then
                    # complete for paths
                    COMPREPLY=( $(compgen -d -- "$cur" ) )
                else
                    word_list=$(__comp_conda_envs)
                fi
                ;;
            remove|uninstall|upgrade|update)
                word_list=$(__comp_conda_packages)
                ;;
            --name|--clone)
                word_list=$(__comp_conda_envs)
                ;;
            --*-file|--file|--which|convert)
                # complete for files
                COMPREPLY=( $(compgen -f -- "$cur" ) )
                ;;
            --*-dir|--*-folder|--subdir|--prefix|--cwd|index)
                # complete for directories
                COMPREPLY=( $(compgen -d -- "$cur" ) )
                ;;
            verify)
                # complete for paths
                COMPREPLY=( $(compgen -fd -- "$cur" ) )
                ;;
        esac
    fi
    if [[ -n $word_list ]]; then
        COMPREPLY=( $(compgen -W '$word_list' -- "$cur" ) )
    fi
} &&
complete -F _comp_conda conda

# vim: ft=sh
