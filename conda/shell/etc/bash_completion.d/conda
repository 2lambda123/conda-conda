# Copyright (C) 2012 Anaconda, Inc
# SPDX-License-Identifier: BSD-3-Clause

# Bash command completion for conda.
#
# This is based on completion for `fish`.
#
# Extended to complete options for subcommands.
#
# Extended to complete file/dirs/paths as appropriate
#
# Dynamic option lookup uses a cache that persists for the duration of the shell. If you
# Updates to the conda command options are relatively rare, but there is a small chance
# that this cache will hold incorrect/incomplete values. A restart of your shell will
# fix this.

# TODO
# * integrate with `conda init`
# * complete `conda env` subcommands

_CONDA_ROOT=$(dirname $(dirname $CONDA_EXE))

function __comp_conda_commands () {
    for f in $_CONDA_ROOT/lib/python*/site-packages/conda/cli/main_*.py
    do
        expr match "$f" '.*_\([a-z]\+\)\.py$'
    done

    for f in $_CONDA_ROOT/bin/conda-*
    do
        if test -x "$f" -a ! -d "$f"
        then
            expr match "$f" '^.*/conda-\(.*\)'
        fi
    done
    echo activate
    echo deactivate
}

function __comp_conda_env_commands() {
    for f in $_CONDA_ROOT/lib/python*/site-packages/conda_env/cli/main_*.py
    do
        expr match "$f" '.*_\([a-z]\+\)\.py$'
    done
}

function __comp_conda_envs() {
    echo base
    conda config --json --show envs_dirs | \
        python -c "import json, os, sys; from os.path import isdir, join; print('\n'.join(d for ed in json.load(sys.stdin)['envs_dirs'] if isdir(ed) for d in os.listdir(ed) if isdir(join(ed, d))))"
}

function __comp_conda_packages() {
    conda list | awk 'NR > 3 {print $1}'
}

# cache conda subcommand help lookups for the duration of the shell
declare -A __comp_conda_cache=()

_comp_conda()
{
    local cur prev words cword
    _init_completion || return

    local word_list
    if [[ $cur == -* ]]; then
        case "$prev" in
            conda)
                word_list=$(_parse_help conda '-h')
                ;;
            *)
                if [[ -z ${__comp_conda_cache[$prev]} ]]; then
                    word_list=$(conda $prev -h 2>&1 | _parse_help -)
                    __comp_conda_cache[$prev]=$word_list
                else
                    word_list=${__comp_conda_cache[$prev]}
                fi
                ;;
        esac
    else
        case "$prev" in
            conda)
                word_list=$(__comp_conda_commands)
                ;;
            env)
                word_list=$(__comp_conda_env_commands)
                ;;
            activate)
                if [[ $cur == ./* || $cur == /* ]]; then
                    # complete for paths
                    COMPREPLY=( $(compgen -d -- "$cur" ) )
                else
                    word_list=$(__comp_conda_envs)
                fi
                ;;
            remove|uninstall|upgrade|update)
                word_list=$(__comp_conda_packages)
                ;;
            --name|--clone)
                word_list=$(__comp_conda_envs)
                ;;
            --*-file|--file|--which|convert)
                # complete for files
                COMPREPLY=( $(compgen -f -- "$cur" ) )
                ;;
            --*-dir|--*-folder|--subdir|--prefix|--cwd|index)
                # complete for directories
                COMPREPLY=( $(compgen -d -- "$cur" ) )
                ;;
            verify)
                # complete for paths
                COMPREPLY=( $(compgen -fd -- "$cur" ) )
                ;;
        esac
    fi
    if [[ -n $word_list ]]; then
        COMPREPLY=( $(compgen -W '$word_list' -- "$cur" ) )
    fi
} &&
complete -F _comp_conda conda

# vim: ft=sh
